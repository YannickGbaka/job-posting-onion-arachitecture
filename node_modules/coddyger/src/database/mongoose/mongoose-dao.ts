import { Model, Document } from 'mongoose';
import { IData, IErrorObject } from '../../interface';
import { defines } from '../../globals';
import { LoggerService, LogLevel } from '../../services';

export class MongoDbDao<T extends Document> implements IData<T> {
	defaultModel!: typeof Model;

	/* -----------------------------------
  | ENREGISTRER UN DOCUMENT
  ----------------------------------- */
	save(data: Document | any): Promise<Document | any> | IErrorObject {
		return new Promise((resolve, reject) => {
			const Q = new this.defaultModel(data);

			Q.save().then((doc: T) => {
				if (!doc) {
					reject(doc);
				} else {
					resolve(doc);
				}
			});
		}).catch((e: any) => {
			LoggerService.log({ type: LogLevel.Error, content: e, location: 'MongoDbDao', method: 'save' });
			return { error: true, data: e, message: defines.message.tryCatch };
		});
	}

	async saveMany(data: Array<Document>): Promise<any> {
		try {
			const doc: Document[] = await this.defaultModel.insertMany(data);
			if (!doc) {
				throw doc;
			} else {
				return doc;
			}
		} catch (e) {
			LoggerService.log({ type: LogLevel.Error, content: e, location: 'MongoDbDao', method: 'saveMany' });
			return { error: true, data: e, message: defines.message.tryCatch };
		}
	}

	update(params: any, data: Document | any): Promise<Document | any> | IErrorObject {
		return new Promise((resolve, reject) => {
			const doc: any = this.defaultModel.updateOne(params, data, { upsert: false });

			if (!doc) {
				reject(doc);
			} else {
				resolve(doc);
			}
		}).catch((e: any) => {
			LoggerService.log({ type: LogLevel.Error, content: e, location: 'MongoDbDao', method: 'update' });
			return { error: true, data: e, message: defines.message.tryCatch };
		});
	}

	updateMany(params: any, data: Document | any): Promise<Document | any> | IErrorObject {
		return new Promise((resolve, reject) => {
			const doc: any = this.defaultModel.updateMany(params, data, { upsert: false });

			if (!doc) {
				reject(doc);
			} else {
				resolve(doc);
			}
		}).catch((e: any) => {
			LoggerService.log({ type: LogLevel.Error, content: e, location: 'MongoDbDao', method: 'update' });
			return { error: true, data: e, message: defines.message.tryCatch };
		});
	}

	/* -----------------------------------
  | SELECTIONNE DES DOCUMENTS
  ----------------------------------- */
	select(payloads: {
		params?: object;
		excludes?: string;
		page?: number;
		pageSize?: number;
		sort?: string;
		orderBy?: string; 
	}): Promise<any | IErrorObject> {
		return new Promise(async (resolve, reject) => {
			let page: number = Number(payloads.page) ?? 1;
			let pageSize: number = Number(payloads.pageSize) ?? 10;
			page = page === 0 ? 1 : page;
			const startIndex = (page - 1) * pageSize;
			const model = this.defaultModel;
			let sortBy: string = payloads.sort;
			let orderBy: string = payloads.orderBy;
	
			// Create sort object
			let sortObject: any = {};
			if (sortBy) {
				sortObject = {
					[sortBy]: orderBy === 'desc' ? -1 : 1
				};
			} else {
				// Default sort by createdAt in descending order if no sortBy is provided
				sortObject = { createdAt: -1 };
			}
	
			const [rows, totalRows] = await Promise.all([
				model
					.find(payloads.params!, payloads.excludes)
					.sort(sortObject)
					.skip(startIndex)
					.limit(pageSize)
					.lean(),
				model.countDocuments(payloads.params)
			]);
	
			if (rows) {
				const totalPages = Math.ceil(totalRows / pageSize);
				const countRowsPerPage = rows.length;
				const totalPagesPerQuery = Math.ceil(totalRows / pageSize);
				resolve({
					rows,
					totalRows,
					totalPages,
					countRowsPerPage,
					totalPagesPerQuery
				});
			} else {
				reject({ rows, totalRows });
			}
		}).catch((e: any) => {
			LoggerService.log({ type: LogLevel.Error, content: JSON.stringify(e), location: 'MongoDbDao', method: 'select' });
			return { error: true, data: e, message: defines.message.tryCatch };
		});
	}

	selectOne(params: object, fields?: string): Promise<Document | any> | IErrorObject {
		return new Promise(async (resolve, reject) => {
			resolve(await this.defaultModel.findOne(params, fields).lean());
		}).catch((e: any) => {
			LoggerService.log({ type: LogLevel.Error, content: e, location: 'MongoDbDao', method: 'selectOne' });
			return { error: true, data: e, message: defines.message.tryCatch };
		});
	}

	selectLatest(status?: string): Promise<Document | any> | IErrorObject {
		return new Promise(async (resolve, reject) => {
			let Q:any;

			if(status) {
				Q = await this.defaultModel.findOne({ status }, '-__v', { sort: { createdAt: -1 } }).lean()
			} else {
				Q = await this.defaultModel.findOne().sort({ createdAt: -1 }).lean()
			}
			resolve(Q);
		}).catch((e: any) => {
			LoggerService.log({ type: LogLevel.Error, content: e, location: 'MongoDbDao', method: 'selectLatest' });
			return { error: true, data: e, message: defines.message.tryCatch };
		}); 
	}

	count(params: object): Promise<any> | IErrorObject {
		return new Promise(async (resolve, reject) => {
			const doc: any = await this.defaultModel.countDocuments(params); 

			resolve(doc);
		}).catch((e: any) => {
			LoggerService.log({ type: LogLevel.Error, content: e, location: 'MongoDbDao', method: 'count' });
			return { error: true, data: e, message: defines.message.tryCatch };
		});
	}

	exist(params: object): Promise<boolean | any> | IErrorObject {
		return new Promise(async (resolve, reject) => {
			const doc: any = await this.defaultModel.countDocuments(params);

			if (doc >= 1) {
				resolve(true);
			} else {
				resolve(false);
			}
		}).catch((e: any) => {
			LoggerService.log({ type: LogLevel.Error, content: e, location: 'MongoDbDao', method: 'exist' });
			return { error: true, data: e, message: defines.message.tryCatch };
		});
	}

	aggregate(params: Array<any>): Promise<any> | IErrorObject {
		return new Promise(async (resolve, reject) => {
			const doc: any = await this.defaultModel.aggregate(params);

			if (!doc) {
				reject(doc);
			}

			resolve(doc);
		}).catch((e: any) => {
			LoggerService.log({ type: LogLevel.Error, content: e, location: 'MongoDbDao', method: 'aggregate' });
			return { error: true, data: e, message: defines.message.tryCatch };
		});
	}

	selectHug(params?: any): Promise<Array<Document> | any> | IErrorObject {
		return new Promise(async (resolve, reject) => {
			let doc = await this.defaultModel.find(params).lean();

			if (!doc) {
				reject(doc);
			} else {
				resolve(doc);
			}
		}).catch((e: any) => {
			LoggerService.log({ type: LogLevel.Error, content: e, location: 'MongoDbDao', method: 'selectHug' });
			return { error: true, data: e, message: defines.message.tryCatch };
		});
	}

	/* -----------------------------------
  | SUPPRIMER UN DOCUMENT
  ----------------------------------- */
	remove(params: any): Promise<any> | IErrorObject {
		return new Promise(async (resolve, reject) => {
			const doc: any = await this.defaultModel.deleteOne(params);

			if (!doc) {
				reject(doc);
			} else {
				resolve(doc);
			}
		}).catch((e: any) => {
			LoggerService.log({ type: LogLevel.Error, content: e, location: 'MongoDbDao', method: 'remove' });
			return { error: true, data: e, message: defines.message.tryCatch };
		});
	}

	removeMany(params: any): Promise<any> | IErrorObject {
		return new Promise(async (resolve, reject) => {
			const doc: any = await this.defaultModel.deleteMany(params);

			if (!doc) {
				reject(doc);
			} else {
				resolve(doc);
			}
		}).catch((e: any) => {
			LoggerService.log({ type: LogLevel.Error, content: e, location: 'MongoDbDao', method: 'removeMany' });
			return { error: true, data: e, message: defines.message.tryCatch };
		});
	}
}
