import * as bcrypt from 'bcrypt';
import * as path from 'path';
import * as fs from 'fs';
import * as http from 'http';
import { LogLevel, LoggerService } from './services';
import env, { defines } from './globals';
import mongoose from 'mongoose';

const coddyger = {
	api: (context: any, promise: Promise<any>) => {
		promise
			.then((res: any) => {
				let status = res.status;
				let message = res.message;
				let data = res.data;
				let isFile: any = res.isFile;

				let response = {
					message: message,
					data: data !== undefined || true ? data : []
				};

				if (isFile) {
					context.setHeader('Content-type', data.type);
					context.sendFile(data.file);
				} else {
					return context.status(status).send(response);
				}
			})
			.catch((err: any) => {
				console.log(err);
				return context.status(500).send({});
			})
			.catch((err: any) => {
				// console.log(err)
				return context
					.status(500)
					.send({ error: true, message: "une erreur interne s'est produite veuillez réssayer plutard" });
			});
	},
	konsole: (msg: any, error = 0) => {
		let message = new Date().toISOString() + '[' + (error === 1 ? 'error' : 'info') + ']' + JSON.stringify(msg);
		if (error === 1) {
			console.error(message);
		} else {
			console.log(message);
		}
	},
	string: {
		isEmpty: function (value : any) {
			return(value === undefined || value === null || value.length<= 0 || value === '')
		},
		isEmailAddress: function(payload: string): boolean {
			const regexp = new RegExp(/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/)
			return regexp.test(payload)
		},
		isNumber: function(payload: string): boolean {
			return /^(?:-?\d+|-?\d{1, 3}(?:, \d{3})+)?(?:\.\d+)?$/.test(payload)
		},
		isDate: function(payload: string):boolean {
			const date = new Date(payload)
    	return !isNaN(date.getTime())
		},
		isValidObjectId: (payload: string):boolean => {
			const objectIdRegex = /^[0-9a-fA-F]{24}$/
    	return objectIdRegex.test(payload)
		},
		generateObjectId: () => {
			try {
				return new mongoose.Types.ObjectId();
			} catch (error) {
				console.error(error);
				return error;
			}
		},
		toObjectId: (value: any) => {
			try {
				return new mongoose.Types.ObjectId(value);
			} catch (error) {
				console.error('ERREUR::', error);
				return error;
			}
		},
		encryptPassword: async (payload: string): Promise<string> => {
			const saltRounds = 10
			const hashedPassword = await bcrypt.hash(payload, saltRounds)
			return hashedPassword
		},
		decryptPassword: async (payload: string, hashedPayload:string): Promise<boolean> => {
      const result = await bcrypt.compare(payload, hashedPayload);
    	return result;
    },
		capitalizeEachWord: (payload: string): string => {
      return payload.split(' ').map(word => {
        const lowercasedWord = word.toLowerCase();
        return lowercasedWord.charAt(0).toUpperCase() + lowercasedWord.slice(1);
    	}).join(' ');
    },
	},
	array: {
		compare: function (array1: Array<any>, array2: Array<any>): boolean {
			if (array1.length !== array2.length) {
        return false;
			}
			for (let i = 0; i < array1.length; i++) {
				if (array1[i] !== array2[i]) {
					return false;
				}
			}
			return true;
		},
		inArray: function (needle: any, haystack: any) {
			let length = haystack.length;
			for (let i = 0; i < length; i++) {
				if (haystack[i] === needle) return true;
			}
			return false;
		}
	},
	buildApiError: (payload: any) => {
		let error = {
			errors: {
				value: coddyger.string.isEmpty(payload.value) ? '' : payload.value,
				msg: payload.msg,
				param: coddyger.string.isEmpty(payload.param) ? '' : payload.param,
				location: coddyger.string.isEmpty(payload.location) ? '' : payload.location
			}
		};

		return error;
	},
	inArray: function (needle: any, haystack: any) {
		let length = haystack.length;
		for (let i = 0; i < length; i++) {
			if (haystack[i] === needle) return true;
		}
		return false;
	},
	getDate: (type: string = '') => {
		var d = new Date(),
			month = '' + (d.getMonth() + 1),
			day = '' + d.getDate(),
			year = d.getFullYear();

		if (month.length < 2) month = '0' + month;

		if (day.length < 2) day = '0' + day;

		return type === 'string' ? [year, month, day].join('-') : new Date([year, month, day].join('-'));
	},
	dateOnlyFormat: (date: any) => {
		var d = new Date(date),
			month = '' + (d.getMonth() + 1),
			day = '' + d.getDate(),
			year = d.getFullYear();

		if (month.length < 2) month = '0' + month;

		if (day.length < 2) day = '0' + day;

		return [year, month, day].join('-');
	},
	file: {
		remove: function (filePath: string) {
			return fs.unlinkSync(filePath);
		},
		extension: function (filename: string) {
			return path.extname(filename).toLowerCase();
		},
		toBase64: (filename: string) => {
			return fs.readFileSync(filename, { encoding: 'base64' });
		},
		exists: (filePath: string) => {
			return fs.existsSync(filePath);
		},
		download: (url: string, filename: string) => {
			return new Promise((resolve, reject) => {
				let file = fs.createWriteStream(coddyger.root() + process.env.DOWNLOAD_PATH + '/' + filename);
				http.get(url, function (response: any) {
					response.pipe(file);
					file.on('finish', function () {
						resolve(file);
						file.close();
					});
				});
			}).catch((e) => {
				return { error: true, data: e, messsage: '' };
			});
		}
	},
	root: () => {
		return path.resolve(process.cwd());
	},
	sanitizeEmail: (email: string): string => {
		if (!email) {
			return email;
		} else {
			let lowercase = email.toLowerCase();
			let nospace = lowercase.trim();

			return nospace;
		}
	},
	paginate: (array: Array<any>, page_size: number, page_number: number) => {
		return array.slice((page_number - 1) * page_size, page_number * page_size);
	},
	calculateDaysBetween(startDate: Date): number {
		const startDateObj: Date = startDate;
		const currentDateObj: Date = new Date();

		// Calculate the time difference in milliseconds
		const timeDifference: number = currentDateObj.getTime() - startDateObj.getTime();
		// Convert milliseconds to days
		const daysDifference = Math.floor(timeDifference / (1000 * 60 * 60 * 24));

		return daysDifference;
	},
	filesInclude(dir: any, payload: string) {
		const exportedFiles: any[] = [];

		const files = fs.readdirSync(dir);

		for (const file of files) {
			// Exclure le fichier index.ts lui-même
			if (file !== 'index.js' && file.endsWith('.' + payload + '.js')) {
				const routeModule = require(path.join(dir, file));
				for (const moduleExport of Object.values(routeModule)) {
					// Vérifiez si c'est une classe (vous pouvez ajouter des vérifications supplémentaires si nécessaire)
					if (typeof moduleExport === 'function') {
						exportedFiles.push(moduleExport);
					}
				}
			}
		}

		// Exportez toutes les classes de route découvertes
		return exportedFiles;
	},
	catchReturn(e: any, location: string, method: string) {
		// Log any errors that occur during the process
		LoggerService.log({ type: LogLevel.Error, content: JSON.stringify(e), location, method });
		// Return a predefined error object for the catch block
		if (env.mode === 'dev') {
			return {
				status: defines.status.serverError,
				message: defines.message.tryCatch,
				data: e
			};
		} else {
			return defines.controlerTryCatchObject;
		}
	},
	buildSlug(prefix: string, lastReference?: string | null): string {
		let newIndex = 1;
		if (lastReference) {
			const lastCodeParts = lastReference.split('-');
			const lastCodeIndex = parseInt(lastCodeParts[lastCodeParts.length - 1], 10);

			if (!isNaN(lastCodeIndex)) {
				newIndex = lastCodeIndex + 1;
			} else {
				throw new Error('Invalid reference format. Cannot extract index.');
			}
		}

		const currentDate = new Date();
		const year = currentDate.getFullYear().toString().slice(-2);
		const month = ('0' + (currentDate.getMonth() + 1)).slice(-2);
		const day = ('0' + currentDate.getDate()).slice(-2);
		const newIndexStr = ('000' + newIndex).slice(-3); 

		let uniq:any = new mongoose.Types.ObjectId();
		uniq = uniq.toString()
		uniq = uniq.substring(uniq.length - 12)

		const code = `${prefix}-${year}${month}${day}-${uniq}-${newIndexStr}`;
		return code;
	},
	getDaysInMonth: (month:number, year:number) => {
		// Validate the month number (1-12)
		if (month < 1 || month > 12) {
				throw new Error("Invalid month number. Month number should be between 1 and 12.");
		}

		// If year is not provided, use the current year
		if (!year) {
				year = new Date().getFullYear();
		}

		// Calculate the number of days in the given month
		return new Date(year, month, 0).getDate();
	},
	getWeeksInMonth: (month:number, year:number) => {
		const weeks = [];
		const firstDay = new Date(year, month - 1, 1);
		const lastDay = new Date(year, month, 0);
		const daysInMonth = lastDay.getDate();

		// Initialiser les variables pour suivre le début et la fin d'une semaine
		let start = 1;
		let dayOfWeek = firstDay.getDay();

		// Si le premier jour du mois n'est pas un lundi, ajuster le début de la première semaine
		if (dayOfWeek !== 1) {
				start = 1;
		}

		for (let i = 1; i <= daysInMonth; i++) {
				dayOfWeek = new Date(year, month - 1, i).getDay();

				// Si le jour est un dimanche (dernier jour de la semaine) ou le dernier jour du mois, c'est la fin de la semaine
				if (dayOfWeek === 0 || i === daysInMonth) {
						const end = i;

						// Ajouter la semaine au tableau
						weeks.push({ start, end });

						// Le début de la nouvelle semaine est le jour suivant
						start = i + 1;
				}
		}
		
		return weeks;
	},
}

export default coddyger;
