import mongoose, { Schema, Document } from 'mongoose';
import coddyger, { IData, IErrorObject, defines, LoggerService, LogLevel, MongoDbDao } from 'coddyger'

export interface IUser {
	_id?: string; // MongoDB generated id
	slug?: string; // Reference of the document
	email?: string; // Title of the document
	password?: string; // Title of the document
	status?: string; // Status of the document - active - removed - archived
	user?: any; // The id of the user that owns or created the document
}

const schema = new mongoose.Schema<IUser>(
	{
		_id: Schema.Types.ObjectId,
		slug: String,
		email: String,
		password: String,
		status: { type: String, enum: ['active', 'archived', 'removed'], default: 'active' },
		user: { type: mongoose.Schema.Types.ObjectId, ref: 'User' }
	},
	{ timestamps: true }
);

const model = mongoose.model<IUser>('User', schema);

export class UserSet extends MongoDbDao<Document> implements IData<Document> {
	defaultModel = model;

	constructor() {
		super();
	}

	props: string = 'email firstname lastname';
	userProps: string = 'slug email lastname firstname';
	setTitle: string = 'UserSet';

	select(payloads: { params?: any; excludes?: string; sort?: object; page?: number; pageSize?: number }): Promise<any> {
		return new Promise(async (resolve, reject) => {
			if (coddyger.string.isEmpty(payloads.params.status)) {
				payloads.params = { ...payloads.params, status: { $nin: ['removed', 'archived'] } };
			}

			let page: number = Number(payloads.page) || 1;
			const pageSize: number = Number(payloads.pageSize) || 10;

			page = page === 0 ? 1 : page;

			const startIndex = (page - 1) * pageSize;
			const model = this.defaultModel;

			const [rows, totalRows] = await Promise.all([
				model
					.find(payloads.params, payloads.excludes)
					.sort({ createdAt: -1 })
					.skip(startIndex)
					.limit(pageSize)
					.lean()
					.populate({
						path: 'user',
						select: this.userProps,
						options: { sort: { createdAt: -1 } }
					}),
				model.countDocuments(payloads.params)
			]);

			if (rows) {
				const totalPages = Math.ceil(totalRows / pageSize);
				const countRowsPerPage = rows.length;
				const totalPagesPerQuery = Math.ceil(totalRows / pageSize);

				resolve({
					rows,
					totalRows,
					totalPages,
					countRowsPerPage,
					totalPagesPerQuery
				});
			} else {
				reject({ rows, totalRows });
			}
		}).catch((e: any) => {
			LoggerService.log({
				type: LogLevel.Error,
				content: JSON.stringify(e),
				location: this.setTitle,
				method: 'select'
			});
			return { error: true, data: e, message: defines.message.tryCatch };
		});
	}

	selectHug(): Promise<Array<Document> | any> {
		return new Promise(async (resolve, reject) => {
			let doc = await this.defaultModel
				.find()
				.lean()
				.populate({
					path: 'user',
					select: this.userProps,
					options: { sort: { createdAt: -1 } }
				});

			if (!doc) {
				reject(doc);
			} else {
				resolve(doc);
			}
		}).catch((e: any) => {
			LoggerService.log({ type: LogLevel.Error, content: e, location: this.setTitle, method: 'selectHug' });
			return { error: true, data: e, message: defines.message.tryCatch };
		});
	}

	selectOne(params: object, fields?: string): Promise<Document | any> {
		return new Promise(async (resolve, reject) => {
			resolve(
				await this.defaultModel
					.findOne(params, fields)
					.lean()
					.populate({
						path: 'user',
						select: this.userProps,
						options: { sort: { createdAt: -1 } }
					})
			);
		}).catch((e: any) => {
			LoggerService.log({ type: LogLevel.Error, content: e, location: this.setTitle, method: 'selectOne' });
			return { error: true, data: e, message: defines.message.tryCatch };
		});
	}
}