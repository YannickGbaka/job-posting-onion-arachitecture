import coddyger, { IData, IErrorObject, defines } from 'coddyger'
import { locale } from "../../public";
import { I{{pascalCase name}}, {{pascalCase name}}Set } from "./";
import { IUser, UserSet } from '../../commons';

const controllerLabel: string = '{{pascalCase name}}Controller';

export class {{pascalCase name}}Controller {
	private readonly dao: IData<I{{pascalCase name}}>;
	private readonly daoUser: IData<IUser>;

	constructor() {
		this.dao = new {{pascalCase name}}Set();
		this.daoUser = new UserSet();
	}

	// Function to save {{pascalCase name}}
	save(item: I{{pascalCase name}}) {
		return new Promise(async (resolve, reject) => {
			// Extracting necessary information from the item
			let title: any = item.title;
			let user: any = item.user;

			if (!coddyger.string.isValidObjectId(user)) {
				resolve({ status: defines.status.clientError, message: locale.wrongObjectId("du compte"), data: null });
			} else {
				const isUser: any = await this.dao.exist({ title });
				const isTitle: any = await this.dao.exist({ title });

				// Validation checks for the item name
				if (isTitle) {
					resolve({
						status: defines.status.clientError,
						message: locale.exist('ce titre'),
						data: null
					});
				} else {
					const theLast:any = await this.dao.selectLatest();
					// Generate a new ObjectId for the item
					item._id = coddyger.string.generateObjectId();
					item.slug = coddyger.buildSlug('TODO', theLast ? theLast.slug : null);

					// Save the item to the local database
					const data: any | IErrorObject = await this.dao.save(item);

					if (data.error) {
						// If there is an error saving to the local database, reject with the error response
						reject(data);
					} else {
						// Retrieve the saved item from the database
						const updatedItem: any = await this.dao.selectOne({ _id: item._id });

						// Resolve with a success response and the updated item
						resolve({
							status: defines.status.requestOK,
							message: locale.controller.successSave,
							data: updatedItem
						});
					}
				}
			}
		}).catch((e: IErrorObject) => {
			return coddyger.catchReturn(e, controllerLabel, 'save');
		});
	}

	// Function to update {{pascalCase name}}
	update(item: I{{pascalCase name}}) {
		return new Promise(async (resolve, reject) => {
			let _id: string = item._id!;
			let title: any = item.title;

			if (!coddyger.string.isValidObjectId(_id)) {
				resolve({ status: defines.status.clientError, message: locale.wrongObjectId("de l'enregistrement"), data: null });
			} else {
				// Controller l'existence de l'élément
				let isData: any = await this.dao.exist({ _id });

				if (isData.error) {
					reject(isData);
				} else if (isData === false) {
					resolve({ status: defines.status.clientError, message: locale.notfound('Enregistrement'), data: null });
				} else {
					let isTitle: any = await this.dao.exist({ title });
					let ownTitle: any = await this.dao.exist({ $and: [{ title }, { _id }] });

					if (isTitle && !ownTitle) {
						resolve({ status: defines.status.clientError, message: locale.notfound('Enregistrement'), data: null });
					} else {
						// Update the item with the history entry
						const update: any = await this.dao.update({ _id }, item);
						if (update.error) {
							reject(update);
						} else {
							// Retrieve the updated item from the database
							const updatedItem: any = await this.dao.selectOne({ _id }, '-__v');
							// Resolve with a success response and the updated item
							resolve({
								status: defines.status.requestOK,
								message: locale.controller.done,
								data: updatedItem
							});
						}
					}
				}
			}
		}).catch((e: IErrorObject) => {
			return coddyger.catchReturn(e, controllerLabel, 'update');
		});
	}

	// Function to remove {{pascalCase name}}
	remove(_id: string) {
		return new Promise(async (resolve, reject) => {
			if (!coddyger.string.isValidObjectId(_id)) {
				resolve({ status: defines.status.clientError, message: locale.controller.wrongObjectId, data: null });
			} else {
				// Controller l'existence de l'élément
				let isData: any = await this.dao.exist({ _id });

				if (isData.error) {
					reject(isData);
				} else if (isData === false) {
					resolve({ status: defines.status.clientError, message: locale.notfound('Enregistrement'), data: null });
				} else {
					const remove: any = await this.dao.update({ _id }, { status: 'removed' });

					if (remove.error) {
						reject(remove);
					} else {
						// Retrieve the updated demand item from the database
						const updatedItem: any = await this.dao.selectOne({ _id });
						// Resolve with a success response and the updated demand item
						resolve({
							status: defines.status.requestOK,
							message: locale.controller.done,
							data: updatedItem
						});
					}
				}
			}
		}).catch((e: IErrorObject) => {
			return coddyger.catchReturn(e, controllerLabel, 'remove');
		});
	}

	// Function to restore {{pascalCase name}}
	restore(_id: string) {
		return new Promise(async (resolve, reject) => {
			if (!coddyger.string.isValidObjectId(_id)) {
				resolve({ status: defines.status.clientError, message: locale.controller.wrongObjectId, data: null });
			} else {
				// Controller l'existence de l'élément
				let isData: any = await this.dao.exist({ _id });

				if (isData.error) {
					reject(isData);
				} else if (isData === false) {
					resolve({ status: defines.status.clientError, message: locale.notfound('Enregistrement'), data: null });
				} else {
					const remove: any = await this.dao.update({ _id }, { status: 'active' });

					if (remove.error) {
						reject(remove);
					} else {
						// Retrieve the updated demand item from the database
						const updatedItem: any = await this.dao.selectOne({ _id });
						// Resolve with a success response and the updated demand item
						resolve({
							status: defines.status.requestOK,
							message: locale.controller.done,
							data: updatedItem
						});
					}
				}
			}
		}).catch((e: IErrorObject) => {
			return coddyger.catchReturn(e, controllerLabel, 'remove');
		});
	}

	// Function to select with parameters {{pascalCase name}}
	select(payloads: { page?: number; pageSize?: number; query?: string; status?: string }) {
		return new Promise(async (resolve, reject) => {
			let page: number = payloads.page || 1;
			let pageSize: number = payloads.pageSize;
			let query: string = payloads.query!;
			let status: any = payloads.status!;

			let data: any | IErrorObject = {};

			if (coddyger.string.isEmpty(query) && coddyger.string.isEmpty(status)) {
				data = await this.dao.select({ params: {}, page, pageSize });
			} else if (!coddyger.string.isEmpty(status)) {
				data = await this.dao.select({ params: { status }, page, pageSize });
			} else {
				data = await this.dao.select({
					params: {
						$or: [
							{ slug: { $regex: query || '', $options: 'i' } },
							{ title: { $regex: query || '', $options: 'i' } },
						]
					},
					page,
					pageSize
				});
			}

			if (data.error) {
				reject(data);
				return;
			}

			const rows: I{{pascalCase name}}[] = data.rows;
			delete data.rows;

			resolve({
				status: defines.status.requestOK,
				message: data,
				data: rows
			});
		}).catch((e: IErrorObject) => {
			return coddyger.catchReturn(e, controllerLabel, 'select');
		});
	}

	// Function to select {{pascalCase name}} by parameters
	selectByParams(params: any, page?: number) {
		return new Promise(async (resolve, reject) => {
			const data: any | IErrorObject = await this.dao.select({ params, page });
			if (data.error) {
				reject(data);
				return;
			}

			const rows: I{{pascalCase name}}[] = data.rows;
			delete data.rows;

			resolve({
				status: defines.status.requestOK,
				message: data,
				data: rows
			});
		}).catch((e: IErrorObject) => {
			return coddyger.catchReturn(e, controllerLabel, 'selectByParams');
		});
	}

	// Function to select all {{pascalCase name}}
	selectAll() {
		return new Promise(async (resolve, reject) => {
			const data: any | IErrorObject = await this.dao.selectHug();
			if (data.error) {
				reject(data);
				return;
			}

			const rows: I{{pascalCase name}}[] = data;

			resolve({
				status: defines.status.requestOK,
				message: {
					totalRows: rows.length
				},
				data: rows || []
			});
		}).catch((e: IErrorObject) => {
			return coddyger.catchReturn(e, controllerLabel, 'selectAll');
		});
	}

	// Function to select detail of {{pascalCase name}} by id
	selectOne(payload: string) {
		return new Promise(async (resolve, reject) => {
			if (!coddyger.string.isValidObjectId(payload)) {
				resolve({ status: defines.status.clientError, message: locale.controller.wrongObjectId, data: null });
			} else {
				const local: any | IErrorObject = await this.dao.selectOne({ _id: payload });

				if (local) {
					resolve({
						status: defines.status.requestOK,
						message: 'OK',
						data: local
					});
				} else {
					resolve({
						status: defines.status.notFound,
						message: locale.notfound('Enregistrement'),
						data: null
					});
					return;
				}
			}
		}).catch((e: IErrorObject) => {
			return coddyger.catchReturn(e, controllerLabel, 'selectOne');
		});
	}
}
