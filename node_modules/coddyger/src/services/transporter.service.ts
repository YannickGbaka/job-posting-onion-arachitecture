import { Kafka, logLevel } from 'kafkajs';
import env from '../globals';
import { LoggerService, LogLevel } from './logger.service';
import coddyger from '../coddyger';

interface TopicInterface {
	id: string;
	set: any;
}

export class TransporterService {
	topics: Array<any> = [];
	constructor(topics: Array<any>) {
		this.topics = topics;
	}

	kafka: Kafka = new Kafka({
		clientId: env.transporter.client!,
		brokers: [env.transporter.broker!],
		logLevel: logLevel.ERROR
	});
	producer = this.kafka.producer();
	consumer = this.kafka.consumer({
		groupId: env.transporter.group!
	});

	send(value: string, topic?: string): Promise<void> {
		return new Promise<void>((resolve, reject) => {
			this.producer.connect().then(() => {
				this.producer.send({
					topic: !coddyger.string.isEmpty(topic) ? topic! : env.transporter.topic!,
					messages: [
						{
							value
						}
					]
				});
			});
		});
	}

	get() {
		try {
			this.consumer.connect().then(async () => {
				coddyger.konsole(`Transporter connected! :: ${env.transporter.broker}`);

				for (let x in this.topics) {
					let topic: TopicInterface = this.topics[x];

					// Start consuming from registrered topics
					await this.consumer.subscribe({ topic: topic.id, fromBeginning: true });
				}

				// Start consumer
				this.consumer.run({
					eachMessage: async (payload: { topic: any; partition: any; message: any }) => {
						let msg = {
							partition: payload.partition,
							offset: payload.message.offset,
							value: payload.message.value.toString()
						};
						console.log('Consuming from ::', payload.topic);
						let data = JSON.parse(msg.value);

						for (let x in this.topics) {
							let topic: TopicInterface = this.topics[x];
							let topicId: string = topic.id;
							let topicSet: any = topic.set;

							if (payload.topic === topicId) {
								this.getData(data, topicSet, topicId);
							}
						}
					}
				});
			});
		} catch (e: any) {
			console.log(e);
			LoggerService.log({
				type: LogLevel.Error,
				content: JSON.stringify(e),
				location: 'TransporterCore',
				method: 'get'
			});
		}
	}

	getData(data: any, set: any, label: string) {
		let _id = data._id;
		const dao: any = new set();

		if (data.action === 'remove') {
			dao.remove({ _id }).then((remove: any) => {
				if (remove.error) {
					LoggerService.log({
						type: LogLevel.Error,
						content: JSON.stringify(remove),
						location: 'TransporterCore',
						method: label + '-remove'
					});
				} else {
					coddyger.konsole(label + ' removed successfully :: ' + _id);
				}
			});
		} else {
			try {
				if (coddyger.string.isValidObjectId(_id)) {
					dao.exist({ _id }).then((exist: any) => {
						if (exist.error) {
							LoggerService.log({
								type: LogLevel.Error,
								content: JSON.stringify(exist),
								location: 'TransporterCore',
								method: label + '-exist'
							});
						} else {
							if (!exist) {
								dao.save(data).then((save: any) => {
									if (save.error) {
										LoggerService.log({
											type: LogLevel.Error,
											content: JSON.stringify(save),
											location: 'TransporterCore',
											method: label + '-save'
										});
									} else {
										coddyger.konsole(label + ' saved successfully :: ' + _id);
									}
								});
							} else {
								delete data._id;

								dao
									.update(
										{
											_id
										},
										data
									)
									.then((update: any) => {
										if (update.error) {
											LoggerService.log({
												type: LogLevel.Error,
												content: JSON.stringify(update),
												location: 'TransporterCore',
												method: label + '-update'
											});
										} else {
											coddyger.konsole(label + ' edited successfully :: ' + _id);
										}
									});
							}
						}
					});
				} else {
					LoggerService.log({
						type: LogLevel.Error,
						content: 'Wrong _id detected::' + _id,
						location: 'TransporterCore',
						method: 'getData'
					});
				}
			} catch (e: any) {
				LoggerService.log({
					type: LogLevel.Error,
					content: JSON.stringify(e),
					location: 'TransporterCore',
					method: 'getData'
				});
			}
		}
	}
}
