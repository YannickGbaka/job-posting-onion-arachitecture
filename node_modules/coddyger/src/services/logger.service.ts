import * as path from 'path';
import * as fs from 'fs';
import coddyger from '../coddyger';

export enum LogLevel {
	Info = 'info',
	Debug = 'debug',
	Warn = 'warn',
	Error = 'error'
}

export class LoggerService {
	static log(payload: { type: LogLevel; content: any; location: string; method: string }) {
		const { type, content, location, method } = payload;

		if (Object.values(LogLevel).includes(type)) {
			LoggerService.createLog(type, content, location, method);
		} else {
			LoggerService.createLog(LogLevel.Error, 'Invalid log type', location, method);
		}
	}

	private static createLog(type: LogLevel, content: any, location: string, method: string) {
		try {
			const currentDate = new Date().toISOString();
			const logDirectory = coddyger.string.isEmpty(location) ? 'mixed' : location;
			const logPath = path.join('/src/logs/', logDirectory);
			const fullPath = path.join(coddyger.root(), logPath);

			if (!fs.existsSync(fullPath)) {
				console.log('Generating log directory...', currentDate);
				fs.mkdirSync(fullPath, { recursive: true, mode: 0o777 });
				console.log('Done!', new Date().toISOString());
			}

			const filename = coddyger.dateOnlyFormat(currentDate);
			const logStream = fs.createWriteStream(path.join(fullPath, `${filename}.log`), { flags: 'a', mode: 0o777 });

			if (type !== LogLevel.Info) {
				logStream.write(
					`[${type}]::${currentDate}::${location}::${method}::${JSON.stringify(content).replace(/\n/g, '')}\n`
				);
			}

			console.log('\nNEW LOG ->', currentDate);
			console.log(content.toString().replace(/\n/g, ''));
		} catch (error) {
			console.log('ERROR::', error);
		}
	}
}
