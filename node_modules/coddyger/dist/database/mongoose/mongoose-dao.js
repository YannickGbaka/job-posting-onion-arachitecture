"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoDbDao = void 0;
const globals_1 = require("../../globals");
const services_1 = require("../../services");
class MongoDbDao {
    /* -----------------------------------
  | ENREGISTRER UN DOCUMENT
  ----------------------------------- */
    save(data) {
        return new Promise((resolve, reject) => {
            const Q = new this.defaultModel(data);
            Q.save().then((doc) => {
                if (!doc) {
                    reject(doc);
                }
                else {
                    resolve(doc);
                }
            });
        }).catch((e) => {
            services_1.LoggerService.log({ type: services_1.LogLevel.Error, content: e, location: 'MongoDbDao', method: 'save' });
            return { error: true, data: e, message: globals_1.defines.message.tryCatch };
        });
    }
    saveMany(data) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const doc = yield this.defaultModel.insertMany(data);
                if (!doc) {
                    throw doc;
                }
                else {
                    return doc;
                }
            }
            catch (e) {
                services_1.LoggerService.log({ type: services_1.LogLevel.Error, content: e, location: 'MongoDbDao', method: 'saveMany' });
                return { error: true, data: e, message: globals_1.defines.message.tryCatch };
            }
        });
    }
    update(params, data) {
        return new Promise((resolve, reject) => {
            const doc = this.defaultModel.updateOne(params, data, { upsert: false });
            if (!doc) {
                reject(doc);
            }
            else {
                resolve(doc);
            }
        }).catch((e) => {
            services_1.LoggerService.log({ type: services_1.LogLevel.Error, content: e, location: 'MongoDbDao', method: 'update' });
            return { error: true, data: e, message: globals_1.defines.message.tryCatch };
        });
    }
    updateMany(params, data) {
        return new Promise((resolve, reject) => {
            const doc = this.defaultModel.updateMany(params, data, { upsert: false });
            if (!doc) {
                reject(doc);
            }
            else {
                resolve(doc);
            }
        }).catch((e) => {
            services_1.LoggerService.log({ type: services_1.LogLevel.Error, content: e, location: 'MongoDbDao', method: 'update' });
            return { error: true, data: e, message: globals_1.defines.message.tryCatch };
        });
    }
    /* -----------------------------------
  | SELECTIONNE DES DOCUMENTS
  ----------------------------------- */
    select(payloads) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            let page = (_a = Number(payloads.page)) !== null && _a !== void 0 ? _a : 1;
            let pageSize = (_b = Number(payloads.pageSize)) !== null && _b !== void 0 ? _b : 10;
            page = page === 0 ? 1 : page;
            const startIndex = (page - 1) * pageSize;
            const model = this.defaultModel;
            let sortBy = payloads.sort;
            let orderBy = payloads.orderBy;
            // Create sort object
            let sortObject = {};
            if (sortBy) {
                sortObject = {
                    [sortBy]: orderBy === 'desc' ? -1 : 1
                };
            }
            else {
                // Default sort by createdAt in descending order if no sortBy is provided
                sortObject = { createdAt: -1 };
            }
            const [rows, totalRows] = yield Promise.all([
                model
                    .find(payloads.params, payloads.excludes)
                    .sort(sortObject)
                    .skip(startIndex)
                    .limit(pageSize)
                    .lean(),
                model.countDocuments(payloads.params)
            ]);
            if (rows) {
                const totalPages = Math.ceil(totalRows / pageSize);
                const countRowsPerPage = rows.length;
                const totalPagesPerQuery = Math.ceil(totalRows / pageSize);
                resolve({
                    rows,
                    totalRows,
                    totalPages,
                    countRowsPerPage,
                    totalPagesPerQuery
                });
            }
            else {
                reject({ rows, totalRows });
            }
        })).catch((e) => {
            services_1.LoggerService.log({ type: services_1.LogLevel.Error, content: JSON.stringify(e), location: 'MongoDbDao', method: 'select' });
            return { error: true, data: e, message: globals_1.defines.message.tryCatch };
        });
    }
    selectOne(params, fields) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            resolve(yield this.defaultModel.findOne(params, fields).lean());
        })).catch((e) => {
            services_1.LoggerService.log({ type: services_1.LogLevel.Error, content: e, location: 'MongoDbDao', method: 'selectOne' });
            return { error: true, data: e, message: globals_1.defines.message.tryCatch };
        });
    }
    selectLatest(status) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            let Q;
            if (status) {
                Q = yield this.defaultModel.findOne({ status }, '-__v', { sort: { createdAt: -1 } }).lean();
            }
            else {
                Q = yield this.defaultModel.findOne().sort({ createdAt: -1 }).lean();
            }
            resolve(Q);
        })).catch((e) => {
            services_1.LoggerService.log({ type: services_1.LogLevel.Error, content: e, location: 'MongoDbDao', method: 'selectLatest' });
            return { error: true, data: e, message: globals_1.defines.message.tryCatch };
        });
    }
    count(params) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const doc = yield this.defaultModel.countDocuments(params);
            resolve(doc);
        })).catch((e) => {
            services_1.LoggerService.log({ type: services_1.LogLevel.Error, content: e, location: 'MongoDbDao', method: 'count' });
            return { error: true, data: e, message: globals_1.defines.message.tryCatch };
        });
    }
    exist(params) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const doc = yield this.defaultModel.countDocuments(params);
            if (doc >= 1) {
                resolve(true);
            }
            else {
                resolve(false);
            }
        })).catch((e) => {
            services_1.LoggerService.log({ type: services_1.LogLevel.Error, content: e, location: 'MongoDbDao', method: 'exist' });
            return { error: true, data: e, message: globals_1.defines.message.tryCatch };
        });
    }
    aggregate(params) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const doc = yield this.defaultModel.aggregate(params);
            if (!doc) {
                reject(doc);
            }
            resolve(doc);
        })).catch((e) => {
            services_1.LoggerService.log({ type: services_1.LogLevel.Error, content: e, location: 'MongoDbDao', method: 'aggregate' });
            return { error: true, data: e, message: globals_1.defines.message.tryCatch };
        });
    }
    selectHug(params) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            let doc = yield this.defaultModel.find(params).lean();
            if (!doc) {
                reject(doc);
            }
            else {
                resolve(doc);
            }
        })).catch((e) => {
            services_1.LoggerService.log({ type: services_1.LogLevel.Error, content: e, location: 'MongoDbDao', method: 'selectHug' });
            return { error: true, data: e, message: globals_1.defines.message.tryCatch };
        });
    }
    /* -----------------------------------
  | SUPPRIMER UN DOCUMENT
  ----------------------------------- */
    remove(params) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const doc = yield this.defaultModel.deleteOne(params);
            if (!doc) {
                reject(doc);
            }
            else {
                resolve(doc);
            }
        })).catch((e) => {
            services_1.LoggerService.log({ type: services_1.LogLevel.Error, content: e, location: 'MongoDbDao', method: 'remove' });
            return { error: true, data: e, message: globals_1.defines.message.tryCatch };
        });
    }
    removeMany(params) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const doc = yield this.defaultModel.deleteMany(params);
            if (!doc) {
                reject(doc);
            }
            else {
                resolve(doc);
            }
        })).catch((e) => {
            services_1.LoggerService.log({ type: services_1.LogLevel.Error, content: e, location: 'MongoDbDao', method: 'removeMany' });
            return { error: true, data: e, message: globals_1.defines.message.tryCatch };
        });
    }
}
exports.MongoDbDao = MongoDbDao;
