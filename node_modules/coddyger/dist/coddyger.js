"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bcrypt = __importStar(require("bcrypt"));
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const http = __importStar(require("http"));
const services_1 = require("./services");
const globals_1 = __importStar(require("./globals"));
const mongoose_1 = __importDefault(require("mongoose"));
const coddyger = {
    api: (context, promise) => {
        promise
            .then((res) => {
            let status = res.status;
            let message = res.message;
            let data = res.data;
            let isFile = res.isFile;
            let response = {
                message: message,
                data: data !== undefined || true ? data : []
            };
            if (isFile) {
                context.setHeader('Content-type', data.type);
                context.sendFile(data.file);
            }
            else {
                return context.status(status).send(response);
            }
        })
            .catch((err) => {
            console.log(err);
            return context.status(500).send({});
        })
            .catch((err) => {
            // console.log(err)
            return context
                .status(500)
                .send({ error: true, message: "une erreur interne s'est produite veuillez réssayer plutard" });
        });
    },
    konsole: (msg, error = 0) => {
        let message = new Date().toISOString() + '[' + (error === 1 ? 'error' : 'info') + ']' + JSON.stringify(msg);
        if (error === 1) {
            console.error(message);
        }
        else {
            console.log(message);
        }
    },
    string: {
        isEmpty: function (value) {
            return (value === undefined || value === null || value.length <= 0 || value === '');
        },
        isEmailAddress: function (payload) {
            const regexp = new RegExp(/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/);
            return regexp.test(payload);
        },
        isNumber: function (payload) {
            return /^(?:-?\d+|-?\d{1, 3}(?:, \d{3})+)?(?:\.\d+)?$/.test(payload);
        },
        isDate: function (payload) {
            const date = new Date(payload);
            return !isNaN(date.getTime());
        },
        isValidObjectId: (payload) => {
            const objectIdRegex = /^[0-9a-fA-F]{24}$/;
            return objectIdRegex.test(payload);
        },
        generateObjectId: () => {
            try {
                return new mongoose_1.default.Types.ObjectId();
            }
            catch (error) {
                console.error(error);
                return error;
            }
        },
        toObjectId: (value) => {
            try {
                return new mongoose_1.default.Types.ObjectId(value);
            }
            catch (error) {
                console.error('ERREUR::', error);
                return error;
            }
        },
        encryptPassword: (payload) => __awaiter(void 0, void 0, void 0, function* () {
            const saltRounds = 10;
            const hashedPassword = yield bcrypt.hash(payload, saltRounds);
            return hashedPassword;
        }),
        decryptPassword: (payload, hashedPayload) => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield bcrypt.compare(payload, hashedPayload);
            return result;
        }),
        capitalizeEachWord: (payload) => {
            return payload.split(' ').map(word => {
                const lowercasedWord = word.toLowerCase();
                return lowercasedWord.charAt(0).toUpperCase() + lowercasedWord.slice(1);
            }).join(' ');
        },
    },
    array: {
        compare: function (array1, array2) {
            if (array1.length !== array2.length) {
                return false;
            }
            for (let i = 0; i < array1.length; i++) {
                if (array1[i] !== array2[i]) {
                    return false;
                }
            }
            return true;
        },
        inArray: function (needle, haystack) {
            let length = haystack.length;
            for (let i = 0; i < length; i++) {
                if (haystack[i] === needle)
                    return true;
            }
            return false;
        }
    },
    buildApiError: (payload) => {
        let error = {
            errors: {
                value: coddyger.string.isEmpty(payload.value) ? '' : payload.value,
                msg: payload.msg,
                param: coddyger.string.isEmpty(payload.param) ? '' : payload.param,
                location: coddyger.string.isEmpty(payload.location) ? '' : payload.location
            }
        };
        return error;
    },
    inArray: function (needle, haystack) {
        let length = haystack.length;
        for (let i = 0; i < length; i++) {
            if (haystack[i] === needle)
                return true;
        }
        return false;
    },
    getDate: (type = '') => {
        var d = new Date(), month = '' + (d.getMonth() + 1), day = '' + d.getDate(), year = d.getFullYear();
        if (month.length < 2)
            month = '0' + month;
        if (day.length < 2)
            day = '0' + day;
        return type === 'string' ? [year, month, day].join('-') : new Date([year, month, day].join('-'));
    },
    dateOnlyFormat: (date) => {
        var d = new Date(date), month = '' + (d.getMonth() + 1), day = '' + d.getDate(), year = d.getFullYear();
        if (month.length < 2)
            month = '0' + month;
        if (day.length < 2)
            day = '0' + day;
        return [year, month, day].join('-');
    },
    file: {
        remove: function (filePath) {
            return fs.unlinkSync(filePath);
        },
        extension: function (filename) {
            return path.extname(filename).toLowerCase();
        },
        toBase64: (filename) => {
            return fs.readFileSync(filename, { encoding: 'base64' });
        },
        exists: (filePath) => {
            return fs.existsSync(filePath);
        },
        download: (url, filename) => {
            return new Promise((resolve, reject) => {
                let file = fs.createWriteStream(coddyger.root() + process.env.DOWNLOAD_PATH + '/' + filename);
                http.get(url, function (response) {
                    response.pipe(file);
                    file.on('finish', function () {
                        resolve(file);
                        file.close();
                    });
                });
            }).catch((e) => {
                return { error: true, data: e, messsage: '' };
            });
        }
    },
    root: () => {
        return path.resolve(process.cwd());
    },
    sanitizeEmail: (email) => {
        if (!email) {
            return email;
        }
        else {
            let lowercase = email.toLowerCase();
            let nospace = lowercase.trim();
            return nospace;
        }
    },
    paginate: (array, page_size, page_number) => {
        return array.slice((page_number - 1) * page_size, page_number * page_size);
    },
    calculateDaysBetween(startDate) {
        const startDateObj = startDate;
        const currentDateObj = new Date();
        // Calculate the time difference in milliseconds
        const timeDifference = currentDateObj.getTime() - startDateObj.getTime();
        // Convert milliseconds to days
        const daysDifference = Math.floor(timeDifference / (1000 * 60 * 60 * 24));
        return daysDifference;
    },
    filesInclude(dir, payload) {
        const exportedFiles = [];
        const files = fs.readdirSync(dir);
        for (const file of files) {
            // Exclure le fichier index.ts lui-même
            if (file !== 'index.js' && file.endsWith('.' + payload + '.js')) {
                const routeModule = require(path.join(dir, file));
                for (const moduleExport of Object.values(routeModule)) {
                    // Vérifiez si c'est une classe (vous pouvez ajouter des vérifications supplémentaires si nécessaire)
                    if (typeof moduleExport === 'function') {
                        exportedFiles.push(moduleExport);
                    }
                }
            }
        }
        // Exportez toutes les classes de route découvertes
        return exportedFiles;
    },
    catchReturn(e, location, method) {
        // Log any errors that occur during the process
        services_1.LoggerService.log({ type: services_1.LogLevel.Error, content: JSON.stringify(e), location, method });
        // Return a predefined error object for the catch block
        if (globals_1.default.mode === 'dev') {
            return {
                status: globals_1.defines.status.serverError,
                message: globals_1.defines.message.tryCatch,
                data: e
            };
        }
        else {
            return globals_1.defines.controlerTryCatchObject;
        }
    },
    buildSlug(prefix, lastReference) {
        let newIndex = 1;
        if (lastReference) {
            const lastCodeParts = lastReference.split('-');
            const lastCodeIndex = parseInt(lastCodeParts[lastCodeParts.length - 1], 10);
            if (!isNaN(lastCodeIndex)) {
                newIndex = lastCodeIndex + 1;
            }
            else {
                throw new Error('Invalid reference format. Cannot extract index.');
            }
        }
        const currentDate = new Date();
        const year = currentDate.getFullYear().toString().slice(-2);
        const month = ('0' + (currentDate.getMonth() + 1)).slice(-2);
        const day = ('0' + currentDate.getDate()).slice(-2);
        const newIndexStr = ('000' + newIndex).slice(-3);
        let uniq = new mongoose_1.default.Types.ObjectId();
        uniq = uniq.toString();
        uniq = uniq.substring(uniq.length - 12);
        const code = `${prefix}-${year}${month}${day}-${uniq}-${newIndexStr}`;
        return code;
    },
    getDaysInMonth: (month, year) => {
        // Validate the month number (1-12)
        if (month < 1 || month > 12) {
            throw new Error("Invalid month number. Month number should be between 1 and 12.");
        }
        // If year is not provided, use the current year
        if (!year) {
            year = new Date().getFullYear();
        }
        // Calculate the number of days in the given month
        return new Date(year, month, 0).getDate();
    },
    getWeeksInMonth: (month, year) => {
        const weeks = [];
        const firstDay = new Date(year, month - 1, 1);
        const lastDay = new Date(year, month, 0);
        const daysInMonth = lastDay.getDate();
        // Initialiser les variables pour suivre le début et la fin d'une semaine
        let start = 1;
        let dayOfWeek = firstDay.getDay();
        // Si le premier jour du mois n'est pas un lundi, ajuster le début de la première semaine
        if (dayOfWeek !== 1) {
            start = 1;
        }
        for (let i = 1; i <= daysInMonth; i++) {
            dayOfWeek = new Date(year, month - 1, i).getDay();
            // Si le jour est un dimanche (dernier jour de la semaine) ou le dernier jour du mois, c'est la fin de la semaine
            if (dayOfWeek === 0 || i === daysInMonth) {
                const end = i;
                // Ajouter la semaine au tableau
                weeks.push({ start, end });
                // Le début de la nouvelle semaine est le jour suivant
                start = i + 1;
            }
        }
        return weeks;
    },
};
exports.default = coddyger;
